CREATE EXTENSION IF NOT EXISTS postgis;

CREATE SCHEMA IF NOT EXISTS dwh;

create table if not exists dwh.d_date (
  tk_date INT4 not null,
  date date,
  date_first_day_of_week date,
  date_last_day_of_week date,
  date_medium text,
  day_in_month INT4,
  is_first_day_of_month boolean,
  is_first_day_of_week boolean,
  is_first_month_of_quarter boolean,
  is_last_day_of_month boolean,
  is_last_day_of_week boolean,
  is_last_month_of_quarter boolean,
  month_abbreviation text,
  month_medium text,
  month_name text,
  month_number INT4,
  month_number_2digits text,
  month_tk INT4,
  quarter_first_month text,
  quarter_last_month text,
  quarter_name text,
  quarter_number INT4,
  quarter_tk INT4,
  week_in_month INT4,
  week_in_year text,
  week_medium text,
  week_number INT4,
  year_month_abbreviation text,
  year_month_number text,
  year_quarter text,
  year4 INT4,
  season text,
  constraint d_date_pk primary key(tk_date)
);

CREATE TABLE IF NOT EXISTS dwh.d_time (
	tk_time int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	hour int4 NOT NULL,
	minute int4 NOT NULL,
	second int4 NOT NULL,
	day_moment text NULL,
	hour_date time NULL,
	hour_2digits text NOT NULL,
	minute_2digits text NOT NULL,
	second_2digits text NOT NULL,
	CONSTRAINT d_time_pk PRIMARY KEY (tk_time)
);

CREATE TABLE dwh.d_station (
	tk_station int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	code_uic bpchar(8),
	station_name text NOT NULL,
	fret boolean ,
	voyageurs boolean ,
	code_ligne bpchar(6) NULL,
	rg_troncon int2 NULL,
	pk text NULL,
	commune text NULL,
	departement text NULL,
	idreseau int4 NULL,
	idgaia uuid NULL,
	x_l93 numeric(10, 3) NULL,
	y_l93 numeric(10, 3) NULL,
	x_wgs84 numeric(9, 6) NULL,
	y_wgs84 numeric(9, 6) NULL,
	geom geography(point, 4326) NULL,
	geom_l93 geometry(point, 2154) NULL,
	inserted_at timestamptz NULL DEFAULT now(),
  CONSTRAINT d_station_pk PRIMARY KEY (tk_station),
  CONSTRAINT d_station_un UNIQUE (station_name, commune, departement)
);
INSERT INTO d_station (tk_station, station_name) VALUES(-1, 'Station inconnue');

CREATE INDEX IF NOT EXISTS dwh_stations_geom_gix ON ods.stations USING gist (geom);
CREATE INDEX IF NOT EXISTS dwh_stations_geom_l93_gix ON ods.stations USING gist (geom_l93);


CREATE TABLE dwh.f_trips (
    tk_trip_fact             INT8 GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    -- busness_key
    trip_id                  text NOT NULL,
    num_train                text NOT NULL,
    ref_date_tk              integer NOT NULL,   -- 
    stop_station_tk          integer NOT NULL,   -- 
    origin_station_tk        integer,            --
    destination_station_tk   integer,            --

    aimed_arrival_date_tk      integer,
    aimed_arrival_time_tk      integer,
    expected_arrival_date_tk   integer,
    expected_arrival_time_tk   integer,

    aimed_departure_date_tk    integer,
    aimed_departure_time_tk    integer,
    expected_departure_date_tk integer,
    expected_departure_time_tk integer,

    delay_arrival_minutes    integer,
    delay_departure_minutes  integer,
    is_starting_point        boolean,
    is_terminus              boolean,

    insert_date              timestamp DEFAULT clock_timestamp(),
    CONSTRAINT f_trips_un UNIQUE (trip_id, ref_date_tk, stop_station_tk),
    CONSTRAINT fk_ref_date          FOREIGN KEY (ref_date_tk)            REFERENCES dwh.d_date(tk_date),
    CONSTRAINT fk_aim_arr_date      FOREIGN KEY (aimed_arrival_date_tk)  REFERENCES dwh.d_date(tk_date),
    CONSTRAINT fk_exp_arr_date      FOREIGN KEY (expected_arrival_date_tk) REFERENCES dwh.d_date(tk_date),
    CONSTRAINT fk_aim_dep_date      FOREIGN KEY (aimed_departure_date_tk)  REFERENCES dwh.d_date(tk_date),
    CONSTRAINT fk_exp_dep_date      FOREIGN KEY (expected_departure_date_tk) REFERENCES dwh.d_date(tk_date),

    CONSTRAINT fk_aim_arr_time      FOREIGN KEY (aimed_arrival_time_tk)    REFERENCES dwh.d_time(tk_time),
    CONSTRAINT fk_exp_arr_time      FOREIGN KEY (expected_arrival_time_tk) REFERENCES dwh.d_time(tk_time),
    CONSTRAINT fk_aim_dep_time      FOREIGN KEY (aimed_departure_time_tk)  REFERENCES dwh.d_time(tk_time),
    CONSTRAINT fk_exp_dep_time      FOREIGN KEY (expected_departure_time_tk) REFERENCES dwh.d_time(tk_time),

    CONSTRAINT fk_stop_station      FOREIGN KEY (stop_station_tk)       REFERENCES dwh.d_station(tk_station),
    CONSTRAINT fk_origin_station    FOREIGN KEY (origin_station_tk)     REFERENCES dwh.d_station(tk_station),
    CONSTRAINT fk_destination_station FOREIGN KEY (destination_station_tk) REFERENCES dwh.d_station(tk_station)
);

INSERT INTO 
  dwh.d_date
(
  tk_date,
  date,
  date_first_day_of_week,
  date_last_day_of_week,
  date_medium,
  day_in_month,
  is_first_day_of_month,
  is_first_day_of_week,
  is_first_month_of_quarter,
  is_last_day_of_month,
  is_last_day_of_week,
  is_last_month_of_quarter,
  month_abbreviation,
  month_medium,
  month_name,
  month_number,
  month_number_2digits,
  month_tk,
  quarter_first_month,
  quarter_last_month,
  quarter_name,
  quarter_number,
  quarter_tk,
  week_in_month,
  week_in_year,
  week_medium,
  year_month_abbreviation,
  year_month_number,
  year_quarter,
  year4
)
SELECT 
  to_char(d,'YYYYMMDD')::integer as tk_date,
  d as date,
  (d - ('' || (dnf-1) || ' day')::interval)::date as date_first_day_of_week,
  (d + ('' || (7-dnf) || ' day')::interval)::date as date_last_day_of_week,
  to_char(d,'DD TMmon') as date_medium,
  extract(day from d)::integer as day_in_month,
  extract(day from d) = 1 as is_first_day_of_month,
  dnf = 1 as is_first_day_of_week,
  extract(month from d) = ANY(array[1,4,7,10]) as is_first_month_of_quarter, 
  extract(month from d) <>  extract(month from (d + '1 day'::interval)::date)  as is_last_day_of_month,
  dnf = 7 as is_last_day_of_week,
  extract(month from d) = ANY(array[3,6,9,12]) as is_last_month_of_quarter,
  to_char(d,'TMmon') as month_abbreviation,
  to_char(d,'TMmon YYYY') as month_medium,
  to_char(d,'TMmonth') as month_name,
  extract(month from d)::integer as month_number,
  to_char(d,'MM') as month_number_2digits,
  to_char(d,'YYYYMM')::integer as month_tk,
  to_char((20180000 + (1+(extract(quarter from d)-1) * 3)*100+ 1)::varchar::date,'TMmonth') as  quarter_first_month, 
  to_char((20180000 + (extract(quarter from d) * 3  * 100) + 1)::varchar::date,'TMmonth') as  quarter_last_month,
  case when  extract(quarter from d)=1 then  '1er' else '' || extract(quarter from d) || 'Ã¨me' end as quarter_name,
  extract(quarter from d)::integer as quarter_number,
  to_char(d,'YYYYQ')::integer as quarter_tk,
  (extract(week from d) - extract(week from (to_char(d,'YYYYMM01')::date))+1)::integer as week_in_month,
  to_char(d, 'YYYY') || '-S' || to_char(d,'IW') as week_in_year,
  'S' || to_char(d,'IW') || to_char(d, 'YYYY') as week_medium,
  to_char(d, 'YYYY-TMmon') as year_month_abbreviation,
  to_char(d, 'YYYY-MM') as year_month_number,
  to_char(d, 'YYYY-TQ') as year_quarter,
  extract(year from d)::integer  as year4
FROM 
(
  select d::date, case when extract(dow from d) = 0 then 7 else extract(dow from d) end as dnf from 
        generate_series(  '20150101'::date ,
        	'20400101'::date         
        	, '1 day'::interval) as dd(d)
) as tmp
order by d desc
ON CONFLICT (tk_date)
DO update 
  set date = excluded.date,
  date_first_day_of_week = excluded.date_first_day_of_week,
  date_last_day_of_week = excluded.date_last_day_of_week,
  date_medium = excluded.date_medium,
  day_in_month = excluded.day_in_month,
  is_first_day_of_month = excluded.is_first_day_of_month,
  is_first_day_of_week = excluded.is_first_day_of_week,
  is_first_month_of_quarter = excluded.is_first_month_of_quarter,
  is_last_day_of_month = excluded.is_last_day_of_month,
  is_last_day_of_week = excluded.is_last_day_of_week,
  is_last_month_of_quarter = excluded.is_last_month_of_quarter,
  month_abbreviation = excluded.month_abbreviation,
  month_medium = excluded.month_medium,
  month_name = excluded.month_name,
  month_number = excluded.month_number,
  month_number_2digits = excluded.month_number_2digits,
  month_tk = excluded.month_tk,
  quarter_first_month = excluded.quarter_first_month,
  quarter_last_month = excluded.quarter_last_month,
  quarter_name = excluded.quarter_name,
  quarter_number = excluded.quarter_number,
  quarter_tk = excluded.quarter_tk,
  week_in_month = excluded.week_in_month,
  week_in_year = excluded.week_in_year,
  week_medium = excluded.week_medium,
  year_month_abbreviation = excluded.year_month_abbreviation,
  year_month_number = excluded.year_month_number,
  year_quarter = excluded.year_quarter,
  year4 = excluded.year4;

INSERT INTO dwh.d_date (tk_date) OVERRIDING SYSTEM VALUE 
VALUES(-1);

INSERT INTO
  dwh.d_time
(
  tk_time,
  hour_date,
  hour,
  minute,
  second,
  day_moment,
  hour_2digits,
  minute_2digits,
  second_2digits
)
SELECT 
  to_char(d,'HH24MISS')::integer as tk_time,
  d as hour_date,
  extract(hour from d)::integer as hour,
  extract(minute from d)::integer as minute,
  extract(second from d)::integer as second,
  CASE 
	WHEN extract(hour from d)::integer>=12 
	THEN 'Soir'
		ELSE 'Matin'
	END AS day_moment,
  to_char(d,'HH24') as hour_2digits,
  to_char(d,'MI') as minute_2digits,
  to_char(d,'SS') as second_2digits
FROM 
(
  select d::time  from 
        generate_series(  '20150101'::date ,
        	'20150102'::date         
        	, '1 second'::interval) as dd(d)
        where d <> '20150102'
) as tmp
order by d desc
ON CONFLICT (tk_time)
DO update 
set  hour_date=excluded.hour_date,
  hour=excluded.hour,
  minute=excluded.minute,
  second=excluded.second,
  hour_2digits=excluded.hour_2digits,
  minute_2digits=excluded.minute_2digits,
  second_2digits=excluded.second_2digits
;
INSERT INTO dwh.d_time
	(tk_time, hour, minute, second, hour_2digits, minute_2digits, second_2digits) OVERRIDING SYSTEM VALUE 
VALUES(-1, 0, 0, 0, 'NC', 'NC', 'NC');


CREATE TABLE dwh.d_train (
    tk_train             INT8 GENERATED ALWAYS AS IDENTITY PRIMARY KEY,                     
    num_train            TEXT NOT NULL,                       
    sens_circulation     TEXT,                                   
    type_train           TEXT,                                   
    sous_type            TEXT,                                   
    categorie_service    TEXT,                                   
    axe_geographique     TEXT,                                   
    region_origine       TEXT,                                   
    vitesse_max_kmh      INTEGER,                                
    plage_numero         TEXT,                                   
    code_mission         TEXT,                                   
    origine_mission      TEXT,                                   
    destination_mission  TEXT,                                   
    periode_service      TEXT,                                   
    commentaire          TEXT,                                   
    date_creation        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,    
    date_maj             TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT d_train_un UNIQUE (num_train)
);
CREATE INDEX idx_num_train ON dwh.d_train(num_train);
CREATE INDEX idx_type_train ON dwh.d_train(type_train);
CREATE INDEX idx_region_origine ON dwh.d_train(region_origine);


CREATE TABLE dwh.f_trips_realtime (
    tk_trip_rt bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    
    trip_id text NOT NULL,
    num_train text NOT NULL,

    ref_date  timestamp NULL,
    stop_station_tk int4 NOT NULL,
    origin_station_tk int4 NULL,
    destination_station_tk int4 NULL,

    aimed_arrival_date_tk int4 NULL,
    aimed_arrival_time_tk int4 NULL,
    expected_arrival_date_tk int4 NULL,
    expected_arrival_time_tk int4 NULL,
    aimed_departure_date_tk int4 NULL,
    aimed_departure_time_tk int4 NULL,
    expected_departure_date_tk int4 NULL,
    expected_departure_time_tk int4 NULL,

    aimed_departure timestamp,
    aimed_arrival timestamp,
    expected_departure timestamp,
    expected_arrival timestamp,
    
    delay_arrival_minutes int4 NULL,
    delay_departure_minutes int4 NULL,
    
    departure_time_trip timestamp,
    arrival_time_trip timestamp,
    
    is_starting_point bool NULL,
    is_terminus bool NULL,

    status_stop text GENERATED ALWAYS AS (
        CASE 
            WHEN expected_departure IS NULL AND NOT is_terminus THEN 'NON_PLANIFIE'
            WHEN expected_arrival IS NULL AND NOT is_starting_point THEN 'NON_PLANIFIE'
            WHEN ((is_terminus OR expected_departure < ref_date) AND expected_arrival < ref_date) THEN 'TERMINE'
            WHEN ((is_terminus OR expected_departure > ref_date) AND expected_arrival > ref_date) THEN 'A_VENIR'
            ELSE 'EN_COURS'
        END
    ) STORED,
    status_trip text GENERATED ALWAYS AS (
        CASE 
	        WHEN (departure_time_trip < ref_date AND arrival_time_trip > ref_date) THEN 'EN_COURS'
            WHEN (arrival_time_trip < ref_date) THEN 'TERMINE'
        END
    ) STORED,
    last_update timestamp DEFAULT now()
);


